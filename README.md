# OderWhat - AI 點餐推薦代理

本專案旨在提供一個由大型語言模型 (LLM) 驅動的智慧點餐服務。它能夠根據使用者輸入的餐廳、人數、預算和偏好，自動分析餐廳資訊並生成一份客製化的推薦菜單。

## 🚀 架構總覽 (Architecture Overview)

本系統的核心架構主要分為兩個階段：**資料分析 (Profiler)** 與 **菜單推薦 (Orchestrator)**。

### 1. 資料分析階段 (Profiler Stage)

此階段負責處理一家餐廳的「冷啟動」(Cold Start)，將網路上的非結構化資料轉換為一份精煉、可信的「黃金檔案」(Golden Profile)。這個過程僅在系統首次遇到一家新餐廳時執行一次，結果會被快取至 Firestore。

- **觸發時機**: 首次分析一家新餐廳時。
- **核心產出**: `Golden Profile` (一份包含已驗證菜色、價格、標籤的結構化資料)。
- **主要代理 (Agents)**:
  - `VisualAgent`: 分析餐廳照片，識別用餐氛圍與推薦菜色。
  - `ReviewAgent`: 分析大量使用者評論，抓取必點菜色與顧客回饋。
  - `SearchAgent`: 從網路上搜尋菜單與補充資訊。
  - `AggregationAgent`: **(主要瓶頸之一)** 綜合以上所有來源的資訊，進行交叉比對與去偽存真，生成最終的黃金檔案。

### 2. 菜單推薦階段 (Orchestrator Stage)

當餐廳的黃金檔案準備就緒後 (無論是即時生成還是從快取讀取)，此階段會根據使用者的即時請求來生成菜單。

- **觸發時機**: 每次使用者發起推薦請求時。
- **核心產出**: 一份為使用者量身打造的推薦菜單。
- **主要代理 (Agents)**:
  - `DishSelectorAgent`: **(主要瓶頸之一)** 作為核心選菜專家，根據使用者偏好和黃金檔案挑選菜色。
  - `BalanceCheckerAgent`: 審視菜單的均衡性 (如蔬菜比例、油膩度)。
  - `QualityAssuranceAgent`: 進行最終的品質確認與修正。

---

## 📊 效能分析與瓶頸 (Performance Analysis & Bottlenecks)

根據最新的效能測試，我們對系統的啟動時間有了量化的了解。

### 測量效能

| 狀態 | 平均耗時 | 說明 |
| :--- | :--- | :--- |
| **冷啟動 (Cold Start)** | **~104.1 秒** (約 1.7 分鐘) | 包含完整的 Profiler + Orchestrator 階段。 |
| **暖啟動 (Warm Start)** | **~52.4 秒** | 已快取黃金檔案，僅執行 Orchestrator 階段。 |

**結論**: 「快取預熱」策略能有效將延遲降低約 **50%**，但 **52 秒**的暖啟動時間對於使用者體驗而言依然過長，顯示 Orchestrator 階段本身也存在瓶頸。

### 冷啟動代理執行時間細目

以下是冷啟動過程中，各個主要代理的平均耗時分析，以找出時間瓶頸。

| 代理 / 階段 (Agent / Stage) | 平均耗時 (秒) | 備註 |
| :--- | :--- | :--- |
| **--- ① 資料分析 (Profiler) ---** | | |
| `[PROFILER]` 資料獲取 (Data Fetching) | 0.81 | 速度極快 |
| `[PROFILER]` 平行代理 (Visual/Review/Search) | 21.60 | 三個代理中最慢者的時間 |
| `[PROFILER]` **`AggregationAgent`** (整合分析) | **25.49** | **主要瓶頸 #1** |
| **--- ② 菜單推薦 (Orchestrator) ---**| | |
| `[ORCHESTRATOR]` **`DishSelectorAgent`** (菜色選擇) | **22.92** | **主要瓶頸 #2** (使用較慢的 Pro 模型) |
| `[ORCHESTRATOR]` `BalanceCheckerAgent` (平衡檢查) | 10.33 | 次要瓶頸 |
| `[ORCHESTRATOR]` `QA Agent` (品質整合) | 7.31 | - |
| **測量總耗時** | **~88.45** | - |

### 已識別的瓶頸

1.  **`AggregationAgent` (25.5 秒)**: 最大的單一瓶頸。將多方來源的雜亂資訊整合成「黃金檔案」的過程極度耗時。
2.  **`DishSelectorAgent` (22.9 秒)**: 第二大瓶頸。作為核心推薦引擎，它使用了更強大但也更慢的 `gemini-2.5-pro` 模型，並處理非常複雜的邏輯。
3.  **平行代理群 (21.6 秒)**: 雖然是平行處理，但整個階段仍需等待最慢的那個代理完成，總耗時也超過 20 秒。

---

## 💡 優化路線圖 (Optimization Roadmap)

基於以上分析，我們規劃了以下優化路徑以提升系統回應速度。

### Tier 1: 快取預熱策略 (Cache Pre-warming)

此策略旨在將「冷啟動」轉換為「暖啟動」，可直接省下約 50% 的時間。
- **做法**: 開發一個批次處理腳本，針對特定區域 (如「大安區」) 的餐廳預先執行「資料分析」階段。
- **進階過濾**: 為了最大化 ROI，此腳本應過濾掉效益低的目標 (如「麥當勞」等大型連鎖店)，專注於最能體現 AI 價值的獨立或特色餐廳。

### Tier 2: Orchestrator 效率提升

此策略旨在將「暖啟動」時間從 `~52` 秒壓縮至更合理的範圍。
1.  **高優先 (Low-hanging Fruit)**:
    - **將 `BalanceCheckerAgent` 無 LLM 化**: 將其檢查邏輯改為 Python 規則判斷，預計可穩定節省 **~10 秒**。
2.  **中期實驗**:
    - **為 `DishSelectorAgent` 更換模型**: 實驗性地將其模型從 `pro` 更換為 `flash`，並建立 A/B 測試以評估對推薦品質的影響。
3.  **長期架構**:
    - **快取最終推薦結果**: 針對高頻率的請求組合 (如「兩人、預算2000元」) 直接快取最終菜單，可將回應時間降至 1 秒內。

---

## 🛠️ 設定與已知問題 (Setup & Known Issues)

-   **Firestore 索引**:
    - 為了查詢使用者活動，`activities` 集合需要一個複合索引。若無此索引，相關查詢將會失敗。
    - **請在 Firestore 中手動建立**:
        - **集合 ID**: `activities`
        - **欄位**: `type` (Ascending), `timestamp` (Ascending)

-   **使用者註冊日期**:
    - 目前 `users` 集合中的文件**沒有** `created_at` 欄位，因此無法準確追蹤新使用者註冊的數量。

---

## 🧪 如何運行測試 (How to Run Tests)

- **效能與計時測試**:
  - 使用以下腳本來測量冷啟動與暖啟動的時間。
  ```bash
  python3 test_cold_start_timing.py
  ```